<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Pattern Generator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Helvetica, Arial, sans-serif;
            background: #ffffff;
            color: #000000;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .sidebar {
            width: 300px;
            background: #f5f5f5;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #d0d0d0;
        }

        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: #ffffff;
        }

        .toolbar {
            background: #f5f5f5;
            padding: 15px 20px;
            border-bottom: 1px solid #d0d0d0;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
            overflow: auto;
            position: relative;
            cursor: grab;
        }

        .canvas-container.dragging {
            cursor: grabbing;
        }

        #canvas {
            background: white;
            border: 1px solid #d0d0d0;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            transform-origin: center center;
            transition: transform 0.2s ease;
            pointer-events: none;
        }

        .zoom-controls {
            position: absolute;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            background: #f5f5f5;
            padding: 10px;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
        }

        .zoom-controls button {
            width: 40px;
            height: 40px;
            padding: 0;
            font-size: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-level {
            text-align: center;
            font-size: 11px;
            color: #666666;
            padding: 5px 0;
        }

        h2 {
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 15px;
            color: #000000;
        }

        .control-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
            color: #333333;
        }

        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }

        input[type="number"] {
            width: 100%;
            padding: 6px;
            background: #ffffff;
            border: 1px solid #d0d0d0;
            color: #000000;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 12px;
        }

        input[type="text"] {
            width: 100%;
            padding: 6px;
            background: #ffffff;
            border: 1px solid #d0d0d0;
            color: #000000;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 12px;
            box-sizing: border-box;
        }

        select {
            width: 100%;
            padding: 6px;
            background: #ffffff;
            border: 1px solid #d0d0d0;
            color: #000000;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 12px;
        }

        button {
            padding: 8px 16px;
            background: #e0e0e0;
            border: 1px solid #c0c0c0;
            border-radius: 6px;
            color: #000000;
            cursor: pointer;
            font-family: Helvetica, Arial, sans-serif;
            font-size: 12px;
            transition: all 0.2s;
        }

        button:hover {
            background: #d0d0d0;
            border-color: #a0a0a0;
        }

        button:active {
            background: #c0c0c0;
        }

        .value-display {
            font-size: 11px;
            color: #666666;
            text-align: right;
        }

        .saved-patterns {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #d0d0d0;
        }

        .pattern-item {
            padding: 8px;
            background: #ffffff;
            margin-bottom: 8px;
            cursor: pointer;
            border: 1px solid #d0d0d0;
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .pattern-item:hover {
            background: #f5f5f5;
            border-color: #b0b0b0;
        }

        .pattern-item button {
            padding: 4px 8px;
            font-size: 10px;
            margin-left: 2px;
        }
        
        .pattern-item button:first-of-type {
            margin-left: 0;
        }

        .status {
            font-size: 11px;
            color: #666666;
            margin-left: auto;
        }

        #version {
            position: fixed;
            bottom: 8px;
            left: 8px;
            font-size: 10px;
            color: #999;
            font-family: Helvetica, Arial, sans-serif;
            z-index: 1000;
        }

        .pattern-preview {
            width: 80px;
            height: 80px;
            border: 1px solid #d0d0d0;
            border-radius: 4px;
            display: inline-block;
            vertical-align: middle;
            margin-left: 10px;
            background: white;
        }
        
        .pattern-preview svg {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div class="sidebar">
        <h2>Pattern Controls</h2>
        
        <div class="control-group">
            <label>Pattern Type</label>
            <select id="patternType">
                <option value="grid">Grid</option>
                <option value="radial">Radial</option>
                <option value="spiral">Spiral</option>
                <option value="singlespiral">Single Spiral</option>
                <option value="wave">Wave</option>
                <option value="truchet">Truchet Tiles</option>
                <option value="noise">Noise Lines</option>
                <option value="voronoi">Voronoi Cells</option>
                <option value="hexgrid">Hexagonal Grid</option>
                <option value="concentric">Concentric Shapes</option>
                <option value="maze">Maze Pattern</option>
                <option value="hilbert">Hilbert Curve</option>
                <option value="islamic">Islamic Star</option>
                <option value="penrose">Penrose Tiling</option>
            </select>
            <div class="pattern-preview" id="patternPreview"></div>
        </div>

        <div class="control-group">
            <label>Density</label>
            <input type="range" id="density" min="5" max="100" value="20">
            <div class="value-display" id="densityValue">20</div>
        </div>

        <div class="control-group">
            <label>Number of Objects</label>
            <input type="range" id="numObjects" min="1" max="20" value="1">
            <div class="value-display" id="numObjectsValue">1</div>
        </div>

        <div class="control-group">
            <label>Scale</label>
            <input type="range" id="scale" min="1" max="50" value="10">
            <div class="value-display" id="scaleValue">10</div>
        </div>

        <div class="control-group">
            <label>Rotation</label>
            <input type="range" id="rotation" min="0" max="360" value="0">
            <div class="value-display" id="rotationValue">0°</div>
        </div>

        <div class="control-group">
            <label>Center X (%)</label>
            <input type="range" id="centerX" min="0" max="100" value="50">
            <div class="value-display" id="centerXValue">50%</div>
        </div>

        <div class="control-group">
            <label>Center Y (%)</label>
            <input type="range" id="centerY" min="0" max="100" value="50">
            <div class="value-display" id="centerYValue">50%</div>
        </div>

        <div class="control-group">
            <label>Randomness</label>
            <input type="range" id="randomness" min="0" max="100" value="0">
            <div class="value-display" id="randomnessValue">0</div>
        </div>

        <div class="control-group">
            <label>Title</label>
            <input type="text" id="titleInput" value="" placeholder="e.g. Noise Lines" oninput="generate()">
        </div>

        <div class="control-group" style="border-top: 1px solid #d0d0d0; padding-top: 15px; margin-top: 5px;">
            <label>Layers</label>
            <input type="range" id="layers" min="1" max="20" value="1">
            <span id="layersValue" class="value-display">1</span>
        </div>

        <div class="control-group">
            <label>Seed</label>
            <input type="number" id="seed" value="12345">
        </div>

        <button onclick="randomize()" style="width: 100%;">Randomize</button>

        <div class="saved-patterns">
            <h2>Saved Patterns</h2>
            <div id="savedPatternsList"></div>
        </div>
    </div>

    <div class="canvas-area">
        <div class="toolbar">
            <button onclick="saveToFile()">Export SVG</button>
            <button onclick="loadFromFile()">Import SVG</button>
            <button onclick="saveToStorage()">Save</button>
            <button onclick="clearStorage()">Clear All Saved</button>
            <span class="status" id="status"></span>
            <input type="file" id="fileInput" accept=".svg" style="display: none;">
        </div>
        
        <div class="canvas-container">
            <svg id="canvas" width="794" height="1123" xmlns="http://www.w3.org/2000/svg" style="shape-rendering: crispEdges;"></svg>
            <div class="zoom-controls">
                <button onclick="zoomIn()" title="Zoom In">+</button>
                <div class="zoom-level" id="zoomLevel">100%</div>
                <button onclick="zoomOut()" title="Zoom Out">−</button>
                <button onclick="resetZoom()" title="Reset Zoom">⊙</button>
            </div>
        </div>
    </div>

    <script>
        // Seeded random number generator
        class Random {
            constructor(seed) {
                this.seed = seed;
            }
            
            next() {
                this.seed = (this.seed * 9301 + 49297) % 233280;
                return this.seed / 233280;
            }
        }

        let currentPattern = null;
        let zoomLevel = 1;
        const minZoom = 0.1;
        const maxZoom = 5;
        const zoomStep = 0.2;
        
        let isPanning = false;
        let startX = 0;
        let startY = 0;
        let scrollLeft = 0;
        let scrollTop = 0;

        // ─── Pattern Store ───────────────────────────────────────────────
        // Tries to use the API backend if one is reachable (same origin /api/health).
        // If not — or if any API call fails — falls back to localStorage /
        // sessionStorage / in-memory, exactly as the standalone version does.
        // The rest of the app just calls patternStore.set/get/remove/keys —
        // it never needs to know which backend is active.
        const patternStore = {
            _data: {},
            _storage: null,
            _backend: 'none',   // 'api' | 'persistent' | 'session' | 'memory'
            _apiBase: '/api',   // relative — works whether served by the backend or not
            _apiKey: null,      // set this if your server has API_KEY enabled
            _browserId: null,   // unique ID for this browser
            
            _getBrowserId() {
                if (this._browserId) return this._browserId;
                
                let id = null;
                try {
                    id = localStorage.getItem('browser-id');
                } catch(e) {}
                
                if (!id) {
                    id = 'browser-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                    try {
                        localStorage.setItem('browser-id', id);
                    } catch(e) {}
                }
                
                this._browserId = id;
                return id;
            },

            // ── local-storage helpers (unchanged from standalone) ──────────
            _test(storage) {
                try {
                    const k = '__ps_test__';
                    storage.setItem(k, '1');
                    storage.removeItem(k);
                    return true;
                } catch(e) { return false; }
            },
            _initLocal() {
                if (this._test(localStorage)) {
                    this._storage = localStorage;
                    this._backend = 'persistent';
                } else if (this._test(sessionStorage)) {
                    this._storage = sessionStorage;
                    this._backend = 'session';
                } else {
                    this._storage = null;
                    this._backend = 'memory';
                }
                // hydrate in-memory cache
                if (this._storage) {
                    for (let i = 0; i < this._storage.length; i++) {
                        const k = this._storage.key(i);
                        if (k && k.startsWith('pattern-')) {
                            this._data[k] = this._storage.getItem(k);
                        }
                    }
                }
            },

            // ── API helpers ───────────────────────────────────────────────
            _headers() {
                const h = { 'Content-Type': 'application/json' };
                if (this._apiKey) h['Authorization'] = `Bearer ${this._apiKey}`;
                return h;
            },
            async _fetch(method, path, body) {
                const opts = { method, headers: this._headers() };
                if (body) opts.body = JSON.stringify(body);
                const res = await fetch(this._apiBase + path, opts);
                if (!res.ok) throw new Error(`API ${res.status}`);
                return res.json();
            },

            // ── main init — probe API, fall back to local ─────────────────
            async init() {
                try {
                    // 2-second timeout — if the server isn't there we don't want to hang
                    const controller = new AbortController();
                    const timeout = setTimeout(() => controller.abort(), 2000);
                    const res = await fetch(this._apiBase + '/health', { signal: controller.signal });
                    clearTimeout(timeout);
                    if (res.ok) {
                        this._backend = 'api';
                        // pull existing patterns from the server into _data
                        const rows = await this._fetch('GET', '/patterns?browser_id=' + encodeURIComponent(this._getBrowserId()));
                        rows.forEach(r => {
                            const key = `pattern-${r.id}`;
                            this._data[key] = JSON.stringify({ id: r.id, params: r.params, timestamp: r.timestamp });
                        });
                        return;
                    }
                } catch(e) { /* server not reachable — fall through */ }

                // No API available — use local storage as before
                this._initLocal();
            },

            // ── write ─────────────────────────────────────────────────────
            async set(key, value) {
                // always mirror locally so the UI updates instantly
                this._data[key] = value;
                if (this._storage) { try { this._storage.setItem(key, value); } catch(e) {} }

                if (this._backend === 'api') {
                    try {
                        const data = JSON.parse(value);
                        const res = await this._fetch('POST', '/patterns', { params: data.params, timestamp: data.timestamp, browser_id: this._getBrowserId() });
                        // server assigned a UUID — re-key locally so delete works
                        const newKey = `pattern-${res.id}`;
                        if (newKey !== key) {
                            this._data[newKey] = JSON.stringify({ id: res.id, params: res.params, timestamp: res.timestamp });
                            delete this._data[key];
                            if (this._storage) { try { this._storage.removeItem(key); } catch(e) {} }
                        }
                    } catch(e) {
                        // API write failed but local copy is already saved — graceful degradation
                        console.warn('API save failed, kept locally:', e.message);
                    }
                }
            },

            // ── read ───────────────────────────────────────────────────────
            get(key) { return this._data[key] || null; },

            // ── delete ────────────────────────────────────────────────────
            async remove(key) {
                delete this._data[key];
                if (this._storage) { try { this._storage.removeItem(key); } catch(e) {} }

                if (this._backend === 'api') {
                    try {
                        // key is "pattern-<uuid>" — extract the uuid
                        const id = key.replace('pattern-', '');
                        await this._fetch('DELETE', `/patterns/${id}?browser_id=` + encodeURIComponent(this._getBrowserId()));
                    } catch(e) { console.warn('API delete failed:', e.message); }
                }
            },

            // ── clear all ─────────────────────────────────────────────────
            async clear() {
                this._data = {};
                if (this._storage) {
                    this.keys().forEach(k => { try { this._storage.removeItem(k); } catch(e) {} });
                }
                if (this._backend === 'api') {
                    try { await this._fetch('DELETE', '/patterns?browser_id=' + encodeURIComponent(this._getBrowserId())); } catch(e) { console.warn('API clear failed:', e.message); }
                }
            },

            // ── list keys ─────────────────────────────────────────────────
            keys() { return Object.keys(this._data).filter(k => k.startsWith('pattern-')); }
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            await patternStore.init();
            loadSavedPatterns();
            updateControlStates(); // Set initial control states
            updatePatternPreview(); // Show initial preview
            generate();
            
            // Auto-save to localStorage on parameter change
            ['patternType', 'density', 'numObjects', 'scale', 'rotation', 'centerX', 'centerY', 'randomness', 'seed', 'layers'].forEach(id => {
                const element = document.getElementById(id);
                if (id === 'patternType') {
                    element.addEventListener('change', () => {
                        updateControlStates();
                        updatePatternPreview();
                        generate();
                    });
                } else {
                    element.addEventListener('change', generate);
                }
                if (element.type === 'range') {
                    element.addEventListener('input', updateValueDisplay);
                }
            });

            document.getElementById('fileInput').addEventListener('change', handleFileLoad);
        });

        function updateValueDisplay(e) {
            const id = e.target.id;
            const value = e.target.value;
            const display = document.getElementById(id + 'Value');
            if (display) {
                if (id === 'rotation') {
                    display.textContent = value + '°';
                } else if (id === 'centerX' || id === 'centerY') {
                    display.textContent = value + '%';
                } else {
                    display.textContent = value;
                }
            }
        }

        function getParams() {
            return {
                type: document.getElementById('patternType').value,
                density: parseInt(document.getElementById('density').value),
                numObjects: parseInt(document.getElementById('numObjects').value),
                scale: parseInt(document.getElementById('scale').value),
                rotation: parseInt(document.getElementById('rotation').value),
                centerX: parseInt(document.getElementById('centerX').value),
                centerY: parseInt(document.getElementById('centerY').value),
                randomness: parseInt(document.getElementById('randomness').value),
                seed: parseInt(document.getElementById('seed').value),
                layers: parseInt(document.getElementById('layers').value),
                title: document.getElementById('titleInput').value
            };
        }

        
        
        // Generate distinct colors for layers
        function getLayerColor(layerIndex, totalLayers) {
            // HSL color wheel with good contrast
            const hue = (layerIndex / totalLayers) * 360;
            return `hsl(${hue}, 70%, 50%)`;
        }

        // ──────────────────────────────────────────────────────────
        // NEW PATTERN TYPES
        // ──────────────────────────────────────────────────────────

        function generateVoronoi(canvas, width, height, params, rng) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const numPoints = Math.floor(params.density * 3);
            
            // Generate random seed points  
            const points = [];
            for (let i = 0; i < numPoints; i++) {
                points.push({
                    x: (rng.next() - 0.5) * width * 1.5,
                    y: (rng.next() - 0.5) * height * 1.5
                });
            }
            
            // Draw Voronoi cell edges
            const gridSize = Math.max(20, 100 / params.density);
            for (let gx = -width/2; gx < width; gx += gridSize) {
                for (let gy = -height/2; gy < height; gy += gridSize) {
                    const distances = points.map((p, i) => ({
                        dist: Math.hypot(p.x - gx, p.y - gy),
                        idx: i
                    })).sort((a, b) => a.dist - b.dist);
                    
                    if (distances.length >= 2) {
                        const p1 = points[distances[0].idx];
                        const p2 = points[distances[1].idx];
                        const mx = (p1.x + p2.x) / 2;
                        const my = (p1.y + p2.y) / 2;
                        const dx = p2.x - p1.x;
                        const dy = p2.y - p1.y;
                        const len = gridSize * 0.3;
                        
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('d', `M ${mx - dy * len} ${my + dx * len} L ${mx + dy * len} ${my - dx * len}`);
                        // stroke inherited from layer
                        path.setAttribute('fill', 'none');
                        g.appendChild(path);
                    }
                }
            }
            canvas.appendChild(g);
        }

        function generateHexGrid(canvas, width, height, params, rng) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const hexSize = 100 / (params.density * 0.5);
            const hexHeight = hexSize * Math.sqrt(3);
            
            for (let row = -5; row < 15; row++) {
                for (let col = -5; col < 15; col++) {
                    const xOffset = row % 2 === 0 ? 0 : hexSize * 1.5;
                    const cx = col * hexSize * 3 + xOffset - width/2;
                    const cy = row * hexHeight - height/2;
                    
                    let d = '';
                    for (let i = 0; i < 6; i++) {
                        // Start at -30 degrees for flat-topped hexagon
                        const angle = (Math.PI / 3) * i - Math.PI / 6;
                        const x = cx + hexSize * Math.cos(angle);
                        const y = cy + hexSize * Math.sin(angle);
                        d += (i === 0 ? 'M' : 'L') + ` ${x} ${y} `;
                    }
                    d += 'Z';
                    
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('d', d);
                    // stroke inherited from layer
                    path.setAttribute('fill', 'none');
                    g.appendChild(path);
                }
            }
            canvas.appendChild(g);
        }

        function generateConcentric(canvas, width, height, params, rng) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const numRings = Math.floor(params.density * 2);
            const maxRadius = Math.max(width, height) * 0.8;
            const shapes = ['circle', 'square', 'triangle'];
            const shape = shapes[Math.floor(rng.next() * shapes.length)];
            
            for (let i = 1; i <= numRings; i++) {
                const r = (i / numRings) * maxRadius;
                let d = '';
                
                if (shape === 'circle') {
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    path.setAttribute('cx', width/2);
                    path.setAttribute('cy', height/2);
                    path.setAttribute('r', r);
                    // stroke inherited from layer
                    path.setAttribute('fill', 'none');
                    g.appendChild(path);
                } else if (shape === 'square') {
                    d = `M ${width/2 - r} ${height/2 - r} L ${width/2 + r} ${height/2 - r} L ${width/2 + r} ${height/2 + r} L ${width/2 - r} ${height/2 + r} Z`;
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('d', d);
                    // stroke inherited from layer
                    path.setAttribute('fill', 'none');
                    g.appendChild(path);
                } else {
                    const h = r * Math.sqrt(3);
                    d = `M ${width/2} ${height/2 - h * 0.66} L ${width/2 + r} ${height/2 + h * 0.33} L ${width/2 - r} ${height/2 + h * 0.33} Z`;
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('d', d);
                    // stroke inherited from layer
                    path.setAttribute('fill', 'none');
                    g.appendChild(path);
                }
            }
            canvas.appendChild(g);
        }

        function generateMaze(canvas, width, height, params, rng) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const cellSize = 100 / (params.density * 0.8);
            const cols = Math.ceil(width / cellSize) + 2;
            const rows = Math.ceil(height / cellSize) + 2;
            
            for (let row = 0; row < rows; row++) {
                for (let col = 0; col < cols; col++) {
                    const x = col * cellSize - width/2;
                    const y = row * cellSize - height/2;
                    
                    if (rng.next() > 0.5) {
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('d', `M ${x} ${y} L ${x + cellSize} ${y}`);
                        // stroke inherited from layer
                        path.setAttribute('fill', 'none');
                        g.appendChild(path);
                    }
                    if (rng.next() > 0.5) {
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        path.setAttribute('d', `M ${x} ${y} L ${x} ${y + cellSize}`);
                        // stroke inherited from layer
                        path.setAttribute('fill', 'none');
                        g.appendChild(path);
                    }
                }
            }
            canvas.appendChild(g);
        }

        function generateHilbert(canvas, width, height, params, rng) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const order = Math.min(Math.floor(params.density * 1.5) + 1, 7);
            const size = Math.min(width, height) * 0.9;
            
            function hilbert(order, size, x, y, xi, xj, yi, yj, path) {
                if (order <= 0) {
                    const px = x + (xi + yi) / 2;
                    const py = y + (xj + yj) / 2;
                    path.push([px, py]);
                } else {
                    hilbert(order - 1, size, x, y, yi/2, yj/2, xi/2, xj/2, path);
                    hilbert(order - 1, size, x + xi/2, y + xj/2, xi/2, xj/2, yi/2, yj/2, path);
                    hilbert(order - 1, size, x + xi/2 + yi/2, y + xj/2 + yj/2, xi/2, xj/2, yi/2, yj/2, path);
                    hilbert(order - 1, size, x + xi/2 + yi, y + xj/2 + yj, -yi/2, -yj/2, -xi/2, -xj/2, path);
                }
            }
            
            const pathPoints = [];
            hilbert(order, size, width/2 - size/2, height/2 - size/2, size, 0, 0, size, pathPoints);
            
            if (pathPoints.length > 0) {
                let d = `M ${pathPoints[0][0]} ${pathPoints[0][1]} `;
                for (let i = 1; i < pathPoints.length; i++) {
                    d += `L ${pathPoints[i][0]} ${pathPoints[i][1]} `;
                }
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', d);
                // stroke inherited from layer
                path.setAttribute('fill', 'none');
                g.appendChild(path);
            }
            canvas.appendChild(g);
        }

        function generateIslamic(canvas, width, height, params, rng) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            // Cap effective density to prevent too many stars (max ~30 for performance)
            const effectiveDensity = Math.min(params.density, 30);
            const gridSize = 150 / effectiveDensity;
            const randomFactor = params.randomness / 100; // 0 to 1
            
            for (let gx = -width/2; gx < width * 1.5; gx += gridSize) {
                for (let gy = -height/2; gy < height * 1.5; gy += gridSize) {
                    // Add random position offset
                    const offsetX = (rng.next() - 0.5) * gridSize * randomFactor * 1.5;
                    const offsetY = (rng.next() - 0.5) * gridSize * randomFactor * 1.5;
                    const cx = gx + offsetX;
                    const cy = gy + offsetY;
                    
                    // Add random size variation (huge range for dramatic effect)
                    const sizeVariation = 0.2 + rng.next() * randomFactor * 5.0;
                    const r = gridSize * 0.4 * sizeVariation;
                    const points = 8;
                    const innerR = r * 0.4;
                    
                    let d = '';
                    for (let i = 0; i < points * 2; i++) {
                        const angle = (Math.PI * 2 / (points * 2)) * i;
                        const radius = i % 2 === 0 ? r : innerR;
                        const x = cx + radius * Math.cos(angle);
                        const y = cy + radius * Math.sin(angle);
                        d += (i === 0 ? 'M' : 'L') + ` ${x} ${y} `;
                    }
                    d += 'Z';
                    
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    path.setAttribute('d', d);
                    // stroke inherited from layer
                    path.setAttribute('fill', 'none');
                    g.appendChild(path);
                }
            }
            canvas.appendChild(g);
        }

        function generatePenrose(canvas, width, height, params, rng) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const tileSize = 80 / params.density;
            
            for (let i = 0; i < params.density * 20; i++) {
                const cx = (rng.next() - 0.5) * width * 1.5;
                const cy = (rng.next() - 0.5) * height * 1.5;
                const angle = rng.next() * Math.PI * 2;
                const thick = rng.next() > 0.5;
                
                const angle1 = thick ? Math.PI / 5 : 2 * Math.PI / 5;
                const pts = [
                    [cx, cy],
                    [cx + tileSize * Math.cos(angle), cy + tileSize * Math.sin(angle)],
                    [cx + tileSize * Math.cos(angle) + tileSize * Math.cos(angle + angle1),
                     cy + tileSize * Math.sin(angle) + tileSize * Math.sin(angle + angle1)],
                    [cx + tileSize * Math.cos(angle + angle1), cy + tileSize * Math.sin(angle + angle1)]
                ];
                
                let d = `M ${pts[0][0]} ${pts[0][1]} `;
                for (let j = 1; j < pts.length; j++) {
                    d += `L ${pts[j][0]} ${pts[j][1]} `;
                }
                d += 'Z';
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', d);
                // stroke inherited from layer
                path.setAttribute('fill', 'none');
                g.appendChild(path);
            }
            canvas.appendChild(g);
        }


        function generate() {
            const params = getParams();
            const canvas = document.getElementById('canvas');
            const width = 794;  // A4 width in pixels at 96dpi
            const height = 1123; // A4 height in pixels at 96dpi
            
            // Exact layout from design (pixel-measured and scaled to A4)
            const outerX = 21;
            const outerY = 21;
            const outerW = 750;
            const outerH = 1079;
            
            // The inner edge of the triple border (black/white/black = 3px each side)
            const innerX = outerX + 3;
            const innerY = outerY + 3;
            const innerW = outerW - 6;
            const innerH = outerH - 6;
            const innerBottom = innerY + innerH; // bottom edge of inner border
            
            // Flush edges: box borders sit right on the inner border stroke (border3).
            // border3 stroke is at outerX+2.5, so its outer pixel edge is at outerX+2.
            const flushLeft   = outerX + 2;
            const flushTop    = outerY + 2;
            const flushRight  = outerX + outerW - 2;
            const flushBottom = outerY + outerH - 2;
            
            // Footer box height and top Y are calculated after padding constants below
            
            // Pattern clip area: everything inside the inner border
            const patternX = innerX;
            const patternY = innerY;
            const patternW = innerW;
            const patternH = innerH; // full inner area — pattern runs behind footer boxes
            
            // Clear canvas
            canvas.innerHTML = '';
            
            // Add clipPath for the pattern area
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
            clipPath.setAttribute('id', 'patternClip');
            const clipRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            clipRect.setAttribute('x', patternX);
            clipRect.setAttribute('y', patternY);
            clipRect.setAttribute('width', patternW);
            clipRect.setAttribute('height', patternH);
            clipPath.appendChild(clipRect);
            defs.appendChild(clipPath);
            canvas.appendChild(defs);
            
            // Wrapper group that clips the pattern
            const clipGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            clipGroup.setAttribute('clip-path', 'url(#patternClip)');
            
            const rng = new Random(params.seed);

            // Scale and rotation are applied as a transform *after* the generator runs.
            // The generators need to draw into a larger area so the pattern still fills
            // the full canvas after the transform shrinks/rotates it.
            // drawW/drawH = canvas size inflated by 1/scaleFactor, so scale shrinking
            // brings it back to exactly filling the canvas. The per-generator diagonal
            // padding on top of that handles rotation coverage.
            const scaleFactor = params.scale / 10;
            const drawW = width / scaleFactor;
            const drawH = height / scaleFactor;

            switch(params.type) {
                case 'grid':
                    generateGrid(clipGroup, drawW, drawH, params, rng);
                    break;
                case 'radial':
                    generateRadial(clipGroup, drawW, drawH, params, rng);
                    break;
                case 'spiral':
                    generateSpiral(clipGroup, drawW, drawH, params, rng);
                    break;
                case 'singlespiral':
                    generateSingleSpiral(clipGroup, drawW, drawH, params, rng);
                    break;
                case 'wave':
                    generateWave(clipGroup, drawW, drawH, params, rng);
                    break;
                case 'truchet':
                    generateTruchet(clipGroup, drawW, drawH, params, rng);
                    break;
                case 'noise':
                    generateNoise(clipGroup, drawW, drawH, params, rng);
                    break;
                case 'voronoi':
                    generateVoronoi(clipGroup, drawW, drawH, params, rng);
                    break;
                case 'hexgrid':
                    generateHexGrid(clipGroup, drawW, drawH, params, rng);
                    break;
                case 'concentric':
                    generateConcentric(clipGroup, drawW, drawH, params, rng);
                    break;
                case 'maze':
                    generateMaze(clipGroup, drawW, drawH, params, rng);
                    break;
                case 'hilbert':
                    generateHilbert(clipGroup, drawW, drawH, params, rng);
                    break;
                case 'islamic':
                    generateIslamic(clipGroup, drawW, drawH, params, rng);
                    break;
                case 'penrose':
                    generatePenrose(clipGroup, drawW, drawH, params, rng);
                    break;
            }
            
            // --- SPLIT INTO LAYERS ---
            // The generator appended a single <g> (possibly with a rotation transform)
            // containing all the pattern paths. We extract those paths and distribute
            // them round-robin across N layer groups, each with its own clipPath.
            const numLayers = Math.max(1, Math.min(20, parseInt(document.getElementById('layers').value) || 1));
            const sourceG = clipGroup.firstElementChild; // the generator's <g>
            const paths = sourceG ? Array.from(sourceG.children) : [];

            // Create N clipPaths in defs (reuse same rect geometry)
            for (let i = 0; i < numLayers; i++) {
                const cp = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
                cp.setAttribute('id', 'layerClip' + i);
                const cr = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                cr.setAttribute('x', patternX);
                cr.setAttribute('y', patternY);
                cr.setAttribute('width', patternW);
                cr.setAttribute('height', patternH);
                cp.appendChild(cr);
                defs.appendChild(cp);
            }

            // Compose scale and rotation around canvas centre.
            const cx = width / 2;
            const cy = height / 2;
            // translate to origin → scale → rotate → translate back
            const composedTransform = `translate(${cx},${cy}) rotate(${params.rotation}) scale(${scaleFactor}) translate(${-cx},${-cy})`;

            // Build each layer group and distribute paths
            for (let i = 0; i < numLayers; i++) {
                const layer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                layer.setAttribute('id', 'layer' + i);
                layer.setAttribute('clip-path', 'url(#layerClip' + i + ')');
                // Inkscape-compatible layer labelling
                layer.setAttribute('inkscape:groupmode', 'layer');
                layer.setAttribute('inkscape:label', 'Layer ' + (i + 1));

                // Inner group carries the composed scale + rotation transform
                const inner = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                inner.setAttribute('transform', composedTransform);
                // Compensate stroke width so it stays at 1px regardless of scale
                inner.setAttribute('stroke-width', (1 / scaleFactor).toFixed(4));
                // Assign color to this layer
                inner.setAttribute('stroke', getLayerColor(i, numLayers));

                // Round-robin: layer i gets paths i, i+N, i+2N, …
                for (let j = i; j < paths.length; j += numLayers) {
                    inner.appendChild(paths[j]);
                }

                layer.appendChild(inner);
                canvas.appendChild(layer);
            }
            
            // --- MEASURE TEXT (needs to happen before drawing) ---
            function measureText(text) {
                const tmp = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                tmp.setAttribute('font-family', 'Helvetica, Arial, sans-serif');
                tmp.setAttribute('font-size', '16');
                tmp.setAttribute('font-weight', 'bold');
                tmp.textContent = text;
                canvas.appendChild(tmp);
                const w = tmp.getBBox().width;
                canvas.removeChild(tmp);
                return w;
            }
            
            const titleValue = document.getElementById('titleInput').value;
            const typeLabels = { grid: 'Grid', radial: 'Radial', spiral: 'Spiral', singlespiral: 'Single Spiral', wave: 'Wave', truchet: 'Truchet Tiles', noise: 'Noise Lines', voronoi: 'Voronoi Cells', hexgrid: 'Hexagonal Grid', concentric: 'Concentric Shapes', maze: 'Maze Pattern', hilbert: 'Hilbert Curve', islamic: 'Islamic Star', penrose: 'Penrose Tiling' };
            const titleDisplay = titleValue || (typeLabels[params.type] || params.type);
            const titlePadX = 8;
            const titlePadY = 4;
            const titlePadBottom = 8;
            const titleTextW = measureText(titleDisplay);
            const titleBoxW = titleTextW + titlePadX * 2;
            
            const now = new Date();
            const dd = String(now.getDate()).padStart(2, '0');
            const mm = String(now.getMonth() + 1).padStart(2, '0');
            const yyyy = now.getFullYear();
            const dateDisplay = `${dd}.${mm}.${yyyy}`;
            const datePadX = 8;
            const datePadY = 4;
            const dateTextW = measureText(dateDisplay);
            const dateBoxW = dateTextW + datePadX * 2;
            
            // Footer box height: 16px font + 4px top + 8px bottom padding
            const footerBoxH = 16 + titlePadY + titlePadBottom;
            const footerTopY = flushBottom - footerBoxH;
            
            // --- FRAME LAYER (title boxes + triple border) ---
            const frameLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            frameLayer.setAttribute('id', 'border');
            frameLayer.setAttribute('id', 'frameLayer');

            // --- TITLE BOX (bottom-left) ---
            // White fill
            const titleBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            titleBg.setAttribute('x', flushLeft);
            titleBg.setAttribute('y', footerTopY);
            titleBg.setAttribute('width', titleBoxW);
            titleBg.setAttribute('height', flushBottom - footerTopY);
            titleBg.setAttribute('fill', '#fff');
            frameLayer.appendChild(titleBg);
            
            // Top border (1px filled rect)
            const titleTop = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            titleTop.setAttribute('x', flushLeft);
            titleTop.setAttribute('y', footerTopY);
            titleTop.setAttribute('width', titleBoxW);
            titleTop.setAttribute('height', '1');
            titleTop.setAttribute('fill', '#000');
            frameLayer.appendChild(titleTop);
            
            // Right border (1px filled rect)
            const titleRight = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            titleRight.setAttribute('x', flushLeft + titleBoxW);
            titleRight.setAttribute('y', footerTopY);
            titleRight.setAttribute('width', '1');
            titleRight.setAttribute('height', flushBottom - footerTopY);
            titleRight.setAttribute('fill', '#000');
            frameLayer.appendChild(titleRight);
            
            // Text
            const titleText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            titleText.setAttribute('x', flushLeft + titleBoxW / 2);
            titleText.setAttribute('y', footerTopY + titlePadY + 16); // padY + font size = baseline
            titleText.setAttribute('font-family', 'Helvetica, Arial, sans-serif');
            titleText.setAttribute('font-size', '16');
            titleText.setAttribute('font-weight', 'bold');
            titleText.setAttribute('text-anchor', 'middle');
            titleText.setAttribute('fill', '#000');
            titleText.textContent = titleDisplay;
            frameLayer.appendChild(titleText);
            
            // --- DATE BOX (bottom-right) ---
            // White fill
            const dateBg = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            dateBg.setAttribute('x', flushRight - dateBoxW);
            dateBg.setAttribute('y', footerTopY);
            dateBg.setAttribute('width', dateBoxW);
            dateBg.setAttribute('height', flushBottom - footerTopY);
            dateBg.setAttribute('fill', '#fff');
            frameLayer.appendChild(dateBg);
            
            // Top border (1px filled rect)
            const dateTop = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            dateTop.setAttribute('x', flushRight - dateBoxW);
            dateTop.setAttribute('y', footerTopY);
            dateTop.setAttribute('width', dateBoxW);
            dateTop.setAttribute('height', '1');
            dateTop.setAttribute('fill', '#000');
            frameLayer.appendChild(dateTop);
            
            // Left border (1px filled rect)
            const dateLeft = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            dateLeft.setAttribute('x', flushRight - dateBoxW);
            dateLeft.setAttribute('y', footerTopY);
            dateLeft.setAttribute('width', '1');
            dateLeft.setAttribute('height', flushBottom - footerTopY);
            dateLeft.setAttribute('fill', '#000');
            frameLayer.appendChild(dateLeft);
            
            // Text
            const dateText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            dateText.setAttribute('x', flushRight - dateBoxW / 2);
            dateText.setAttribute('y', footerTopY + datePadY + 16); // padY + font size = baseline
            dateText.setAttribute('font-family', 'Helvetica, Arial, sans-serif');
            dateText.setAttribute('font-size', '16');
            dateText.setAttribute('font-weight', 'bold');
            dateText.setAttribute('text-anchor', 'middle');
            dateText.setAttribute('fill', '#000');
            dateText.textContent = dateDisplay;
            frameLayer.appendChild(dateText);
            
            // --- TRIPLE BORDER (drawn last so it sits on top) ---
            // Outer black
            const border1 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            border1.setAttribute('x', outerX);
            border1.setAttribute('y', outerY);
            border1.setAttribute('width', outerW);
            border1.setAttribute('height', outerH);
            border1.setAttribute('fill', 'none');
            border1.setAttribute('stroke', '#000');
            border1.setAttribute('stroke-width', '1');
            frameLayer.appendChild(border1);
            
            // White
            const border2 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            border2.setAttribute('x', outerX + 1);
            border2.setAttribute('y', outerY + 1);
            border2.setAttribute('width', outerW - 2);
            border2.setAttribute('height', outerH - 2);
            border2.setAttribute('fill', 'none');
            border2.setAttribute('stroke', '#fff');
            border2.setAttribute('stroke-width', '1');
            frameLayer.appendChild(border2);
            
            // Inner black
            const border3 = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            border3.setAttribute('x', outerX + 2);
            border3.setAttribute('y', outerY + 2);
            border3.setAttribute('width', outerW - 4);
            border3.setAttribute('height', outerH - 4);
            border3.setAttribute('fill', 'none');
            border3.setAttribute('stroke', '#000');
            border3.setAttribute('stroke-width', '1');
            frameLayer.appendChild(border3);

            canvas.appendChild(frameLayer);
            
            // Update value displays
            ['density', 'numObjects', 'scale', 'rotation', 'centerX', 'centerY', 'randomness', 'layers'].forEach(id => {
                const element = document.getElementById(id);
                const display = document.getElementById(id + 'Value');
                if (display) {
                    if (id === 'rotation') {
                        display.textContent = element.value + '°';
                    } else if (id === 'centerX' || id === 'centerY') {
                        display.textContent = element.value + '%';
                    } else {
                        display.textContent = element.value;
                    }
                }
            });
            
            currentPattern = params;
            showStatus('Pattern generated');
        }

        function generateGrid(canvas, width, height, params, rng) {
            const spacingX = width / params.density;
            const spacingY = height / params.density;
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            // Draw from -diagonal to +diagonal centred on canvas centre.
            // This guarantees full coverage at any rotation or scale.
            const diagonal = Math.sqrt(width * width + height * height);
            const cx = width / 2;
            const cy = height / 2;
            const startX = cx - diagonal;
            const endX   = cx + diagonal;
            const startY = cy - diagonal;
            const endY   = cy + diagonal;
            
            const iMin = Math.floor((startY) / spacingY) - 1;
            const iMax = Math.ceil((endY) / spacingY) + 1;
            const jMin = Math.floor((startX) / spacingX) - 1;
            const jMax = Math.ceil((endX) / spacingX) + 1;
            
            // Horizontal lines
            for (let i = iMin; i <= iMax; i++) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                let d = '';
                
                for (let j = jMin; j <= jMax; j++) {
                    let x = j * spacingX;
                    let y = i * spacingY;
                    
                    if (params.randomness > 0) {
                        x += (rng.next() - 0.5) * spacingX * (params.randomness / 100);
                        y += (rng.next() - 0.5) * spacingY * (params.randomness / 100);
                    }
                    
                    if (j === jMin) {
                        d += `M ${x} ${y}`;
                    } else {
                        d += ` L ${x} ${y}`;
                    }
                }
                
                path.setAttribute('d', d);
                path.setAttribute('fill', 'none');
                // stroke inherited from layer
                g.appendChild(path);
            }
            
            // Vertical lines
            for (let j = jMin; j <= jMax; j++) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                let d = '';
                
                for (let i = iMin; i <= iMax; i++) {
                    let x = j * spacingX;
                    let y = i * spacingY;
                    
                    if (params.randomness > 0) {
                        x += (rng.next() - 0.5) * spacingX * (params.randomness / 100);
                        y += (rng.next() - 0.5) * spacingY * (params.randomness / 100);
                    }
                    
                    if (i === iMin) {
                        d += `M ${x} ${y}`;
                    } else {
                        d += ` L ${x} ${y}`;
                    }
                }
                
                path.setAttribute('d', d);
                path.setAttribute('fill', 'none');
                // stroke inherited from layer
                g.appendChild(path);
            }
            
            
            canvas.appendChild(g);
        }

        function generateRadial(canvas, width, height, params, rng) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const diagonal = Math.sqrt(width * width + height * height);
            const maxRadius = diagonal; // Use full diagonal to ensure coverage when rotated
            
            // Generate multiple radial patterns
            for (let obj = 0; obj < params.numObjects; obj++) {
                let cx, cy;
                
                if (params.numObjects === 1) {
                    // Single object uses the center point controls
                    cx = width * (params.centerX / 100);
                    cy = height * (params.centerY / 100);
                } else {
                    // Multiple objects distributed in a grid pattern
                    const cols = Math.ceil(Math.sqrt(params.numObjects));
                    const rows = Math.ceil(params.numObjects / cols);
                    const col = obj % cols;
                    const row = Math.floor(obj / cols);
                    
                    cx = (width / (cols + 1)) * (col + 1);
                    cy = (height / (rows + 1)) * (row + 1);
                    
                    // Add some randomness to position if randomness is enabled
                    if (params.randomness > 0) {
                        cx += (rng.next() - 0.5) * (width / cols) * (params.randomness / 100);
                        cy += (rng.next() - 0.5) * (height / rows) * (params.randomness / 100);
                    }
                }
                
                // Concentric circles
                for (let i = 1; i <= params.density; i++) {
                    const radius = (i / params.density) * maxRadius;
                    const points = Math.max(32, Math.floor(params.density * 2));
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    let d = '';
                    
                    for (let j = 0; j <= points; j++) {
                        const angle = (j / points) * Math.PI * 2;
                        let r = radius;
                        
                        if (params.randomness > 0) {
                            r += (rng.next() - 0.5) * radius * (params.randomness / 100);
                        }
                        
                        const x = cx + Math.cos(angle) * r;
                        const y = cy + Math.sin(angle) * r;
                        
                        if (j === 0) {
                            d += `M ${x} ${y}`;
                        } else {
                            d += ` L ${x} ${y}`;
                        }
                    }
                    
                    path.setAttribute('d', d);
                    path.setAttribute('fill', 'none');
                    // stroke inherited from layer
                    g.appendChild(path);
                }
                
                // Radial lines
                const spokes = Math.max(8, Math.floor(params.density * 0.8));
                for (let j = 0; j < spokes; j++) {
                    const angle = (j / spokes) * Math.PI * 2;
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    
                    const x1 = cx;
                    const y1 = cy;
                    const x2 = cx + Math.cos(angle) * maxRadius;
                    const y2 = cy + Math.sin(angle) * maxRadius;
                    
                    path.setAttribute('d', `M ${x1} ${y1} L ${x2} ${y2}`);
                    path.setAttribute('fill', 'none');
                    // stroke inherited from layer
                    g.appendChild(path);
                }
            }
            
            
            canvas.appendChild(g);
        }

        function generateSpiral(canvas, width, height, params, rng) {
            const cx = width / 2;
            const cy = height / 2;
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            const points = params.density * 20;
            const diagonal = Math.sqrt(width * width + height * height);
            const maxRadius = diagonal; // Use full diagonal to ensure coverage when rotated
            const spirals = Math.max(1, Math.floor(params.density / 10));
            
            for (let s = 0; s < spirals; s++) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                let d = '';
                
                for (let i = 0; i < points; i++) {
                    const t = i / points;
                    const angle = t * Math.PI * 2 * (params.density / 3) + (s / spirals) * Math.PI * 2;
                    let radius = t * maxRadius;
                    
                    if (params.randomness > 0) {
                        radius += (rng.next() - 0.5) * 20 * (params.randomness / 100);
                    }
                    
                    const x = cx + Math.cos(angle) * radius;
                    const y = cy + Math.sin(angle) * radius;
                    
                    if (i === 0) {
                        d += `M ${x} ${y}`;
                    } else {
                        d += ` L ${x} ${y}`;
                    }
                }
                
                path.setAttribute('d', d);
                path.setAttribute('fill', 'none');
                // stroke inherited from layer
                g.appendChild(path);
            }
            
            
            canvas.appendChild(g);
        }

        function generateSingleSpiral(canvas, width, height, params, rng) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            
            const diagonal = Math.sqrt(width * width + height * height);
            const maxRadius = diagonal; // Use full diagonal to ensure coverage when rotated
            
            // Calculate points based on density
            const rotations = params.density / 2;
            const pointsPerRotation = 100;
            const points = Math.floor(rotations * pointsPerRotation);
            
            // Generate multiple spirals
            for (let obj = 0; obj < params.numObjects; obj++) {
                let cx, cy;
                
                if (params.numObjects === 1) {
                    // Single object uses the center point controls
                    cx = width * (params.centerX / 100);
                    cy = height * (params.centerY / 100);
                } else {
                    // Multiple objects distributed in a grid pattern
                    const cols = Math.ceil(Math.sqrt(params.numObjects));
                    const rows = Math.ceil(params.numObjects / cols);
                    const col = obj % cols;
                    const row = Math.floor(obj / cols);
                    
                    cx = (width / (cols + 1)) * (col + 1);
                    cy = (height / (rows + 1)) * (row + 1);
                    
                    // Add some randomness to position if randomness is enabled
                    if (params.randomness > 0) {
                        cx += (rng.next() - 0.5) * (width / cols) * (params.randomness / 100);
                        cy += (rng.next() - 0.5) * (height / rows) * (params.randomness / 100);
                    }
                }
                
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                let d = '';
                
                for (let i = 0; i <= points; i++) {
                    const t = i / points;
                    
                    const angle = t * rotations * Math.PI * 2;
                    let radius = t * maxRadius;
                    
                    if (params.randomness > 0) {
                        radius += (rng.next() - 0.5) * 30 * (params.randomness / 100);
                    }
                    
                    const x = cx + Math.cos(angle) * radius;
                    const y = cy + Math.sin(angle) * radius;
                    
                    if (i === 0) {
                        d += `M ${x} ${y}`;
                    } else {
                        d += ` L ${x} ${y}`;
                    }
                }
                
                path.setAttribute('d', d);
                path.setAttribute('fill', 'none');
                // stroke inherited from layer
                g.appendChild(path);
            }
            
            
            canvas.appendChild(g);
        }

        function generateWave(canvas, width, height, params, rng) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const rows = params.density;
            const cols = params.density * 2;
            const spacingY = height / rows;
            const spacingX = width / cols;
            
            const diagonal = Math.sqrt(width * width + height * height);
            const cx = width / 2;
            const cy = height / 2;
            
            const iMin = Math.floor((cy - diagonal) / spacingY) - 1;
            const iMax = Math.ceil((cy + diagonal) / spacingY) + 1;
            const jMin = Math.floor((cx - diagonal) / spacingX) - 1;
            const jMax = Math.ceil((cx + diagonal) / spacingX) + 1;
            
            for (let i = iMin; i <= iMax; i++) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                let d = '';
                
                for (let j = jMin; j <= jMax; j++) {
                    const x = j * spacingX;
                    let y = i * spacingY + Math.sin((j / cols) * Math.PI * 2 * (params.density / 10)) * spacingY * 0.4;
                    
                    if (params.randomness > 0) {
                        y += (rng.next() - 0.5) * 10 * (params.randomness / 100);
                    }
                    
                    if (j === jMin) {
                        d += `M ${x} ${y}`;
                    } else {
                        d += ` L ${x} ${y}`;
                    }
                }
                
                path.setAttribute('d', d);
                path.setAttribute('fill', 'none');
                // stroke inherited from layer
                g.appendChild(path);
            }
            
            
            canvas.appendChild(g);
        }

        function generateTruchet(canvas, width, height, params, rng) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const tileSizeX = width / params.density;
            const tileSizeY = height / params.density;
            
            const diagonal = Math.sqrt(width * width + height * height);
            const cx = width / 2;
            const cy = height / 2;
            
            const iMin = Math.floor((cy - diagonal) / tileSizeY) - 1;
            const iMax = Math.ceil((cy + diagonal) / tileSizeY) + 1;
            const jMin = Math.floor((cx - diagonal) / tileSizeX) - 1;
            const jMax = Math.ceil((cx + diagonal) / tileSizeX) + 1;
            
            for (let j = iMin; j <= iMax; j++) {
                for (let i = jMin; i <= jMax; i++) {
                    const x = i * tileSizeX;
                    const y = j * tileSizeY;
                    const type = rng.next() > 0.5 ? 0 : 1;
                    
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    
                    if (type === 0) {
                        path.setAttribute('d', `M ${x} ${y} Q ${x + tileSizeX} ${y} ${x + tileSizeX} ${y + tileSizeY}`);
                    } else {
                        path.setAttribute('d', `M ${x + tileSizeX} ${y} Q ${x} ${y} ${x} ${y + tileSizeY}`);
                    }
                    
                    path.setAttribute('fill', 'none');
                    // stroke inherited from layer
                    g.appendChild(path);
                }
            }
            
            
            canvas.appendChild(g);
        }

        function generateNoise(canvas, width, height, params, rng) {
            const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            const lines = params.density * 2;
            const spacingY = height / lines;
            const points = 100;
            const spacingX = width / points;
            
            const diagonal = Math.sqrt(width * width + height * height);
            const cx = width / 2;
            const cy = height / 2;
            
            const iMin = Math.floor((cy - diagonal) / spacingY) - 1;
            const iMax = Math.ceil((cy + diagonal) / spacingY) + 1;
            const jMin = Math.floor((cx - diagonal) / spacingX) - 1;
            const jMax = Math.ceil((cx + diagonal) / spacingX) + 1;
            
            for (let i = iMin; i <= iMax; i++) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                let d = '';
                
                for (let j = jMin; j <= jMax; j++) {
                    const x = j * spacingX;
                    const baseY = i * spacingY;
                    const noiseY = (rng.next() - 0.5) * spacingY * 0.8 * (params.randomness / 100 + 0.1);
                    const y = baseY + noiseY;
                    
                    if (j === jMin) {
                        d += `M ${x} ${y}`;
                    } else {
                        d += ` L ${x} ${y}`;
                    }
                }
                
                path.setAttribute('d', d);
                path.setAttribute('fill', 'none');
                // stroke inherited from layer
                g.appendChild(path);
            }
            
            
            canvas.appendChild(g);
        }

        function randomize() {
            // Keep current pattern type, only randomize parameters
            document.getElementById('seed').value = Math.floor(Math.random() * 1000000);
            document.getElementById('density').value = Math.floor(Math.random() * 60) + 10;
            document.getElementById('numObjects').value = Math.floor(Math.random() * 10) + 1;
            document.getElementById('scale').value = Math.floor(Math.random() * 40) + 5;
            document.getElementById('rotation').value = Math.floor(Math.random() * 360);
            document.getElementById('centerX').value = Math.floor(Math.random() * 80) + 10;
            document.getElementById('centerY').value = Math.floor(Math.random() * 80) + 10;
            document.getElementById('randomness').value = Math.floor(Math.random() * 100);
            generate();
        }
        
        // Control relevance per pattern type
        
        function updatePatternPreview() {
            const patternType = document.getElementById('patternType').value;
            const preview = document.getElementById('patternPreview');
            
            // Pre-generated SVG thumbnails for each pattern type
            const thumbnails = {
                'grid': '<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><g stroke="black" stroke-width="1" fill="none"><line x1="0" y1="20" x2="80" y2="20"/><line x1="0" y1="40" x2="80" y2="40"/><line x1="0" y1="60" x2="80" y2="60"/><line x1="20" y1="0" x2="20" y2="80"/><line x1="40" y1="0" x2="40" y2="80"/><line x1="60" y1="0" x2="60" y2="80"/></g></svg>',
                
                'radial': '<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><g stroke="black" stroke-width="1" fill="none"><line x1="40" y1="40" x2="40" y2="5"/><line x1="40" y1="40" x2="65" y2="18"/><line x1="40" y1="40" x2="75" y2="40"/><line x1="40" y1="40" x2="65" y2="62"/><line x1="40" y1="40" x2="40" y2="75"/><line x1="40" y1="40" x2="15" y2="62"/><line x1="40" y1="40" x2="5" y2="40"/><line x1="40" y1="40" x2="15" y2="18"/></g></svg>',
                
                'spiral': '<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><path d="M 40 40 Q 45 35 50 40 T 55 50 T 50 60 T 35 60 T 25 50 T 25 35 T 40 25 T 60 30 T 70 50" stroke="black" stroke-width="1.5" fill="none"/></svg>',
                
                'singlespiral': '<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><path d="M 40 40 L 45 38 L 48 42 L 46 48 L 38 50 L 32 46 L 30 38 L 36 30 L 46 28 L 56 34 L 60 46 L 54 58 L 40 64" stroke="black" stroke-width="1.5" fill="none"/></svg>',
                
                'wave': '<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><g stroke="black" stroke-width="1" fill="none"><path d="M 0 15 Q 20 5 40 15 T 80 15"/><path d="M 0 30 Q 20 20 40 30 T 80 30"/><path d="M 0 45 Q 20 35 40 45 T 80 45"/><path d="M 0 60 Q 20 50 40 60 T 80 60"/></g></svg>',
                
                'truchet': '<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><g stroke="black" stroke-width="1" fill="none"><path d="M 0 0 Q 0 20 20 20"/><path d="M 20 0 Q 20 20 40 20"/><path d="M 40 0 Q 60 0 60 20"/><path d="M 60 0 Q 80 0 80 20"/><path d="M 0 20 Q 20 20 20 40"/><path d="M 20 20 Q 40 20 40 40"/><path d="M 40 20 Q 40 40 60 40"/><path d="M 60 20 Q 60 40 80 40"/><path d="M 0 40 Q 0 60 20 60"/><path d="M 40 40 Q 60 40 60 60"/></g></svg>',
                
                'noise': '<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><g stroke="black" stroke-width="0.5"><line x1="10" y1="15" x2="25" y2="20"/><line x1="30" y1="10" x2="45" y2="18"/><line x1="50" y1="12" x2="62" y2="8"/><line x1="15" y1="30" x2="28" y2="35"/><line x1="35" y1="32" x2="48" y2="28"/><line x1="55" y1="35" x2="68" y2="32"/><line x1="12" y1="50" x2="20" y2="55"/><line x1="25" y1="48" x2="40" y2="52"/><line x1="45" y1="50" x2="58" y2="48"/><line x1="18" y1="65" x2="32" y2="70"/><line x1="38" y1="68" x2="52" y2="65"/><line x1="58" y1="70" x2="70" y2="68"/></g></svg>',
                
                'voronoi': '<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><g stroke="black" stroke-width="1" fill="none"><path d="M 20 0 L 20 35 L 0 50"/><path d="M 20 35 L 40 25 L 60 40"/><path d="M 40 25 L 50 0 L 80 0"/><path d="M 40 25 L 20 35 L 0 50 L 0 80 L 30 80"/><path d="M 60 40 L 80 30 L 80 80 L 50 80"/></g></svg>',
                
                'hexgrid': '<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><g stroke="black" stroke-width="1" fill="none"><path d="M 10 20 L 15 12 L 25 12 L 30 20 L 25 28 L 15 28 Z"/><path d="M 30 20 L 35 12 L 45 12 L 50 20 L 45 28 L 35 28 Z"/><path d="M 50 20 L 55 12 L 65 12 L 70 20 L 65 28 L 55 28 Z"/><path d="M 20 39 L 25 31 L 35 31 L 40 39 L 35 47 L 25 47 Z"/><path d="M 40 39 L 45 31 L 55 31 L 60 39 L 55 47 L 45 47 Z"/><path d="M 10 58 L 15 50 L 25 50 L 30 58 L 25 66 L 15 66 Z"/><path d="M 30 58 L 35 50 L 45 50 L 50 58 L 45 66 L 35 66 Z"/><path d="M 50 58 L 55 50 L 65 50 L 70 58 L 65 66 L 55 66 Z"/></g></svg>',
                
                'concentric': '<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><g stroke="black" stroke-width="1" fill="none"><circle cx="40" cy="40" r="10"/><circle cx="40" cy="40" r="20"/><circle cx="40" cy="40" r="30"/></g></svg>',
                
                'maze': '<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><g stroke="black" stroke-width="1.5"><line x1="0" y1="0" x2="80" y2="0"/><line x1="0" y1="20" x2="60" y2="20"/><line x1="20" y1="20" x2="20" y2="40"/><line x1="0" y1="40" x2="80" y2="40"/><line x1="40" y1="40" x2="40" y2="60"/><line x1="0" y1="60" x2="80" y2="60"/><line x1="60" y1="60" x2="60" y2="80"/><line x1="0" y1="0" x2="0" y2="80"/><line x1="20" y1="0" x2="20" y2="20"/><line x1="40" y1="0" x2="40" y2="20"/><line x1="60" y1="20" x2="60" y2="40"/><line x1="80" y1="0" x2="80" y2="80"/></g></svg>',
                
                'hilbert': '<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><path d="M 10 10 L 10 30 L 30 30 L 30 10 L 50 10 L 50 30 L 70 30 L 70 10 L 70 50 L 50 50 L 50 30 L 30 30 L 30 50 L 10 50 L 10 70 L 30 70 L 30 50 L 50 50 L 50 70 L 70 70" stroke="black" stroke-width="1.5" fill="none"/></svg>',
                
                'islamic': '<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><g stroke="black" stroke-width="1" fill="none"><path d="M 40 15 L 46 32 L 63 32 L 50 42 L 56 59 L 40 49 L 24 59 L 30 42 L 17 32 L 34 32 Z"/></g></svg>',
                
                'penrose': '<svg viewBox="0 0 80 80" xmlns="http://www.w3.org/2000/svg"><g stroke="black" stroke-width="1" fill="none"><path d="M 30 20 L 40 10 L 50 20 L 45 35 Z"/><path d="M 50 20 L 65 25 L 60 40 L 45 35 Z"/><path d="M 45 35 L 60 40 L 50 55 L 40 45 Z"/><path d="M 40 45 L 50 55 L 40 65 L 25 55 Z"/><path d="M 25 55 L 15 50 L 20 35 L 30 40 Z"/><path d="M 30 40 L 20 35 L 30 20 L 40 30 Z"/></g></svg>'
            };
            
            preview.innerHTML = thumbnails[patternType] || '';
        }

        function updateControlStates() {
            const patternType = document.getElementById('patternType').value;
            
            // Define which controls each pattern uses
            const controlMap = {
                // Pattern uses: density, numObjects, scale, rotation, centerX, centerY, randomness
                'grid': { density: true, numObjects: false, scale: true, rotation: true, centerX: false, centerY: false, randomness: true },
                'radial': { density: true, numObjects: false, scale: true, rotation: true, centerX: true, centerY: true, randomness: true },
                'spiral': { density: true, numObjects: false, scale: true, rotation: true, centerX: true, centerY: true, randomness: true },
                'singlespiral': { density: true, numObjects: false, scale: true, rotation: true, centerX: true, centerY: true, randomness: false },
                'wave': { density: true, numObjects: false, scale: true, rotation: true, centerX: false, centerY: false, randomness: true },
                'truchet': { density: true, numObjects: false, scale: true, rotation: true, centerX: false, centerY: false, randomness: false },
                'noise': { density: true, numObjects: false, scale: true, rotation: true, centerX: false, centerY: false, randomness: true },
                'voronoi': { density: true, numObjects: false, scale: true, rotation: true, centerX: false, centerY: false, randomness: true },
                'hexgrid': { density: true, numObjects: false, scale: true, rotation: true, centerX: false, centerY: false, randomness: true },
                'concentric': { density: true, numObjects: false, scale: true, rotation: true, centerX: true, centerY: true, randomness: true },
                'maze': { density: true, numObjects: false, scale: true, rotation: true, centerX: false, centerY: false, randomness: true },
                'hilbert': { density: true, numObjects: false, scale: true, rotation: true, centerX: false, centerY: false, randomness: false },
                'islamic': { density: true, numObjects: false, scale: true, rotation: true, centerX: false, centerY: false, randomness: true },
                'penrose': { density: true, numObjects: false, scale: true, rotation: true, centerX: false, centerY: false, randomness: true }
            };
            
            const controls = controlMap[patternType] || {};
            
            // Enable/disable controls based on pattern type
            ['density', 'numObjects', 'scale', 'rotation', 'centerX', 'centerY', 'randomness'].forEach(id => {
                const element = document.getElementById(id);
                const container = element.closest('.control-group');
                
                if (controls[id] === false) {
                    element.disabled = true;
                    if (container) container.style.opacity = '0.4';
                } else {
                    element.disabled = false;
                    if (container) container.style.opacity = '1';
                }
            });
        }

        function saveToFile() {
            const canvas = document.getElementById('canvas');
            const svgClone = canvas.cloneNode(true);
            
            // Get clip bounds
            const defs = svgClone.querySelector('defs');
            const clipRect = defs ? defs.querySelector('clipPath rect') : null;
            
            if (!clipRect) {
                console.warn('No clip rect found');
                exportSVG(svgClone);
                return;
            }
            
            const clipX = parseFloat(clipRect.getAttribute('x'));
            const clipY = parseFloat(clipRect.getAttribute('y'));
            const clipW = parseFloat(clipRect.getAttribute('width'));
            const clipH = parseFloat(clipRect.getAttribute('height'));
            const clipRight = clipX + clipW;
            const clipBottom = clipY + clipH;
            
            console.log(`Clip bounds: [${clipX}, ${clipY}] to [${clipRight}, ${clipBottom}]`);
            
            // Cohen-Sutherland line clipping
            function clipLine(x0, y0, x1, y1) {
                const INSIDE = 0, LEFT = 1, RIGHT = 2, BOTTOM = 4, TOP = 8;
                function outcode(x, y) {
                    let code = INSIDE;
                    if (x < clipX) code |= LEFT;
                    else if (x > clipRight) code |= RIGHT;
                    if (y < clipY) code |= TOP;
                    else if (y > clipBottom) code |= BOTTOM;
                    return code;
                }
                
                let out0 = outcode(x0, y0);
                let out1 = outcode(x1, y1);
                
                while (true) {
                    if (!(out0 | out1)) return { x0, y0, x1, y1 };
                    if (out0 & out1) return null;
                    
                    const out = out0 || out1;
                    let x, y;
                    
                    if (out & TOP) {
                        x = x0 + (x1 - x0) * (clipY - y0) / (y1 - y0);
                        y = clipY;
                    } else if (out & BOTTOM) {
                        x = x0 + (x1 - x0) * (clipBottom - y0) / (y1 - y0);
                        y = clipBottom;
                    } else if (out & RIGHT) {
                        y = y0 + (y1 - y0) * (clipRight - x0) / (x1 - x0);
                        x = clipRight;
                    } else {
                        y = y0 + (y1 - y0) * (clipX - x0) / (x1 - x0);
                        x = clipX;
                    }
                    
                    if (out === out0) {
                        x0 = x; y0 = y;
                        out0 = outcode(x0, y0);
                    } else {
                        x1 = x; y1 = y;
                        out1 = outcode(x1, y1);
                    }
                }
            }
            
            // Clip a quadratic bezier curve - returns array of line segments
            function clipQuadBezier(x0, y0, cx, cy, x1, y1, steps = 20) {
                const segments = [];
                let lastX = x0, lastY = y0;
                
                for (let i = 1; i <= steps; i++) {
                    const t = i / steps;
                    const t1 = 1 - t;
                    const px = t1*t1 * x0 + 2*t1*t * cx + t*t * x1;
                    const py = t1*t1 * y0 + 2*t1*t * cy + t*t * y1;
                    
                    const clipped = clipLine(lastX, lastY, px, py);
                    if (clipped) {
                        segments.push(clipped);
                    }
                    
                    lastX = px;
                    lastY = py;
                }
                
                return segments;
            }
            
            // Process layers (exclude border layer which contains title/date/borders)
            const layers = svgClone.querySelectorAll('g[id^="layer"]:not(#border)');
            let totalPaths = 0;
            let totalKept = 0;
            
            layers.forEach(layer => {
                const innerG = layer.querySelector('g[transform]');
                if (!innerG) return;
                
                const originalLayer = canvas.querySelector(`g[id="${layer.id}"]`);
                const originalInnerG = originalLayer ? originalLayer.querySelector('g[transform]') : null;
                
                if (!originalInnerG) return;
                
                const matrix = originalInnerG.getCTM();
                const paths = Array.from(innerG.querySelectorAll('path'));
                totalPaths += paths.length;
                
                paths.forEach(path => {
                    const d = path.getAttribute('d');
                    if (!d) return;
                    
                    // Parse all commands
                    const tokens = d.match(/[MLQZ]|[\d.\-]+/g) || [];
                    let newD = '';
                    let currentX = 0, currentY = 0;
                    let needMove = true;
                    let i = 0;
                    
                    while (i < tokens.length) {
                        const cmd = tokens[i++];
                        
                        if (cmd === 'M') {
                            const x = parseFloat(tokens[i++]);
                            const y = parseFloat(tokens[i++]);
                            const tx = matrix.a * x + matrix.c * y + matrix.e;
                            const ty = matrix.b * x + matrix.d * y + matrix.f;
                            currentX = tx;
                            currentY = ty;
                            needMove = true;
                            
                        } else if (cmd === 'L') {
                            const x = parseFloat(tokens[i++]);
                            const y = parseFloat(tokens[i++]);
                            const tx = matrix.a * x + matrix.c * y + matrix.e;
                            const ty = matrix.b * x + matrix.d * y + matrix.f;
                            
                            const clipped = clipLine(currentX, currentY, tx, ty);
                            if (clipped) {
                                if (needMove) {
                                    newD += `M ${clipped.x0.toFixed(2)} ${clipped.y0.toFixed(2)} `;
                                    needMove = false;
                                }
                                newD += `L ${clipped.x1.toFixed(2)} ${clipped.y1.toFixed(2)} `;
                                currentX = clipped.x1;
                                currentY = clipped.y1;
                            } else {
                                needMove = true;
                            }
                            currentX = tx;
                            currentY = ty;
                            
                        } else if (cmd === 'Q') {
                            const cx = parseFloat(tokens[i++]);
                            const cy = parseFloat(tokens[i++]);
                            const x = parseFloat(tokens[i++]);
                            const y = parseFloat(tokens[i++]);
                            
                            const tcx = matrix.a * cx + matrix.c * cy + matrix.e;
                            const tcy = matrix.b * cx + matrix.d * cy + matrix.f;
                            const tx = matrix.a * x + matrix.c * y + matrix.e;
                            const ty = matrix.b * x + matrix.d * y + matrix.f;
                            
                            const segments = clipQuadBezier(currentX, currentY, tcx, tcy, tx, ty);
                            
                            for (const seg of segments) {
                                if (needMove) {
                                    newD += `M ${seg.x0.toFixed(2)} ${seg.y0.toFixed(2)} `;
                                    needMove = false;
                                }
                                newD += `L ${seg.x1.toFixed(2)} ${seg.y1.toFixed(2)} `;
                                currentX = seg.x1;
                                currentY = seg.y1;
                            }
                            
                            if (segments.length === 0) {
                                needMove = true;
                            }
                            
                            currentX = tx;
                            currentY = ty;
                            
                        } else if (cmd === 'Z') {
                            // Close path - ignore for now
                        }
                    }
                    
                    if (newD.trim().length > 0) {
                        path.setAttribute('d', newD.trim());
                        totalKept++;
                    } else {
                        path.remove();
                    }
                });
                
                innerG.removeAttribute('transform');
                layer.removeAttribute('clip-path');
            });
            
            console.log(`Processed ${totalPaths} paths, kept ${totalKept}`);
            
            if (defs) {
                defs.querySelectorAll('clipPath').forEach(cp => cp.remove());
            }
            
            exportSVG(svgClone);
        }
        
        function exportSVG(svgClone) {
            svgClone.setAttribute('width', '210mm');
            svgClone.setAttribute('height', '297mm');
            svgClone.setAttribute('viewBox', '0 0 794 1123');
            svgClone.setAttribute('xmlns:inkscape', 'http://www.inkscape.org/namespaces/inkscape');
            
            const svgData = new XMLSerializer().serializeToString(svgClone);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const titleInput = document.getElementById('titleInput').value.trim();
            const filename = titleInput
                ? titleInput.replace(/[^a-zA-Z0-9_\- ]/g, '').replace(/\s+/g, '-')
                : 'pattern-' + Date.now();
            a.download = `${filename}.svg`;
            a.click();
            URL.revokeObjectURL(url);
            showStatus('SVG exported');
        }
        function loadFromFile() {

            document.getElementById('fileInput').click();
        }

        function handleFileLoad(e) {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(event) {
                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(event.target.result, 'image/svg+xml');
                const svgElement = svgDoc.documentElement;
                
                const canvas = document.getElementById('canvas');
                canvas.innerHTML = svgElement.innerHTML;
                
                showStatus('SVG loaded from file');
            };
            reader.readAsText(file);
        }

        async function saveToStorage() {
            const params = getParams();
            const timestamp = Date.now();
            const key = `pattern-${timestamp}`;
            
            const data = {
                params: params,
                timestamp: timestamp,
                svg: new XMLSerializer().serializeToString(document.getElementById('canvas'))
            };
            
            await patternStore.set(key, JSON.stringify(data));
            loadSavedPatterns();
            const persistMsg = patternStore._backend === 'api'        ? ' (saved to server)' :
                               patternStore._backend === 'persistent' ? '' :
                               patternStore._backend === 'session'    ? ' (session only — lost on reload)' :
                                                                        ' (memory only — lost on reload)';
            showStatus('Saved' + persistMsg);
        }

        function loadSavedPatterns() {
            const container = document.getElementById('savedPatternsList');
            container.innerHTML = '';
            
            const keys = patternStore.keys().sort().reverse();
            
            if (keys.length === 0) {
                container.innerHTML = '<div style="font-size: 11px; color: #999999;">No saved patterns</div>';
                return;
            }
            
            keys.forEach(key => {
                const data = JSON.parse(patternStore.get(key));
                const date = new Date(data.timestamp);
                
                const typeLabels = { grid: 'Grid', radial: 'Radial', spiral: 'Spiral', singlespiral: 'Single Spiral', wave: 'Wave', truchet: 'Truchet Tiles', noise: 'Noise Lines', voronoi: 'Voronoi Cells', hexgrid: 'Hexagonal Grid', concentric: 'Concentric Shapes', maze: 'Maze Pattern', hilbert: 'Hilbert Curve', islamic: 'Islamic Star', penrose: 'Penrose Tiling' };
                const label = data.params.title || typeLabels[data.params.type] || data.params.type;
                const item = document.createElement('div');
                item.className = 'pattern-item';
                item.innerHTML = `
                    <span>${label} — ${date.toLocaleDateString()} ${date.toLocaleTimeString()}</span>
                    <button onclick="loadPattern('${key}')">Load</button>
                    <button onclick="renamePattern('${key}')">Rename</button>
                    <button onclick="deletePattern('${key}')">Delete</button>
                `;
                container.appendChild(item);
            });
        }

        function loadPattern(key) {
            const data = JSON.parse(patternStore.get(key));
            const params = data.params;
            
            document.getElementById('patternType').value = params.type;
            document.getElementById('density').value = params.density;
            document.getElementById('numObjects').value = params.numObjects || 1;
            document.getElementById('scale').value = params.scale;
            document.getElementById('rotation').value = params.rotation;
            document.getElementById('centerX').value = params.centerX || 50;
            document.getElementById('centerY').value = params.centerY || 50;
            document.getElementById('randomness').value = params.randomness;
            document.getElementById('seed').value = params.seed;
            document.getElementById('layers').value = params.layers || 1;
            document.getElementById('titleInput').value = params.title || '';
            
            generate();
            showStatus('Pattern loaded');
        }

        async function deletePattern(key) {
            if (confirm('Delete this pattern?')) {
                await patternStore.remove(key);
                loadSavedPatterns();
                showStatus('Pattern deleted');
            }
        }

        async function renamePattern(key) {
            const data = JSON.parse(patternStore.get(key));
            const currentTitle = data.params.title || '';
            const newTitle = prompt('Rename pattern:', currentTitle);
            if (newTitle !== null && newTitle.trim() !== '') {
                data.params.title = newTitle.trim();
                await patternStore.set(key, JSON.stringify(data));
                loadSavedPatterns();
                showStatus('Pattern renamed');
            }
        }

        async function clearStorage() {
            if (confirm('Clear all saved patterns?')) {
                await patternStore.clear();
                loadSavedPatterns();
                showStatus('All patterns cleared');
            }
        }

        function showStatus(message) {
            const status = document.getElementById('status');
            status.textContent = message;
            setTimeout(() => {
                status.textContent = '';
            }, 2000);
        }

        function zoomIn() {
            if (zoomLevel < maxZoom) {
                zoomLevel = Math.min(zoomLevel + zoomStep, maxZoom);
                applyZoom();
            }
        }

        function zoomOut() {
            if (zoomLevel > minZoom) {
                zoomLevel = Math.max(zoomLevel - zoomStep, minZoom);
                applyZoom();
            }
        }

        function resetZoom() {
            zoomLevel = 1;
            applyZoom();
        }

        function applyZoom() {
            const canvas = document.getElementById('canvas');
            canvas.style.transform = `scale(${zoomLevel})`;
            document.getElementById('zoomLevel').textContent = Math.round(zoomLevel * 100) + '%';
        }

        // Mouse wheel zoom
        document.addEventListener('DOMContentLoaded', () => {
            const container = document.querySelector('.canvas-container');
            
            // Zoom with mouse wheel (no modifier key needed)
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -zoomStep : zoomStep;
                zoomLevel = Math.max(minZoom, Math.min(maxZoom, zoomLevel + delta));
                applyZoom();
            });
            
            // Click and drag to pan
            container.addEventListener('mousedown', (e) => {
                // Don't pan if clicking on zoom controls
                if (e.target.closest('.zoom-controls')) return;
                
                isPanning = true;
                container.classList.add('dragging');
                startX = e.pageX - container.offsetLeft;
                startY = e.pageY - container.offsetTop;
                scrollLeft = container.scrollLeft;
                scrollTop = container.scrollTop;
            });
            
            container.addEventListener('mouseleave', () => {
                isPanning = false;
                container.classList.remove('dragging');
            });
            
            container.addEventListener('mouseup', () => {
                isPanning = false;
                container.classList.remove('dragging');
            });
            
            container.addEventListener('mousemove', (e) => {
                if (!isPanning) return;
                e.preventDefault();
                const x = e.pageX - container.offsetLeft;
                const y = e.pageY - container.offsetTop;
                const walkX = (x - startX) * 1.5; // Scroll speed multiplier
                const walkY = (y - startY) * 1.5;
                container.scrollLeft = scrollLeft - walkX;
                container.scrollTop = scrollTop - walkY;
            });
        });
    </script>
    <div id="version">v1.0</div>
</body>
</html>